---
title: "Smart buildings"
author: "Cameron Roach"
date: "9 November 2017"
bibliography: library.bib
nocite: |
  @Murphy2012-bc, @Friedman2001-vq
output:
  ioslides_presentation:
    css: css/styles.css
    fig_height: 5.5
    fig_width: 10
    logo: fig/BA-LOGO-RGB-Web-LRG.png
    widescreen: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = FALSE,
	message = FALSE,
	warning = FALSE
)

rm(list=ls())

require(readr)
require(dplyr)
require(tidyr)
require(ggplot2)
require(lubridate)
require(hms)

set.seed(1234)

ba_palette = c("#3d6b78", "#60bb6b", "#d52f59", "#f5b835", "#2dbbd6",
               "#816b93", "#b84f80", "#f08c3e", "#c1b97d", "#7e450a",
               "#d4d700", "#00978f")

data <- read_csv("data/data.csv") %>% 
  mutate(DT = as.POSIXct(time, origin="1970-01-01"),
         Date = floor_date(DT, "day"),
         Time = hms(second(DT), minute(DT), hour(DT))) %>% 
  rename(Value = value) %>% 
  select(-time)

sensor_sample <- sample(unique(data$Sensor), 10)
```

## TODO

* Finish BMS section
* Show a plot of spectral embedding. Also clustering maybe?
* Add a reference to that spectral clustering paper.

## Overview

* Smart buildings
* Analysing the data
* Building an end product

# Smart buildings | Trying to be smart with commercial building data

## How do commercial buildings work?

* Facility managers oversee the day to day operations of a commercial building.
* Building operations are automated by Building Management Systems (BMSs).

## What is a BMS?

* Commercial buildings contain Building Management Systems (BMSs).
* Control heating, cooling, ventilation and lighting systems.
* Typically contain a lot of sensors (>100,000).

## How does this work in practice?

Contractor comes in, sets up a BMS. The BMS will behave in a certain way based predefined rules.

For instance - if high temperature readings are recorded in a room, more cooling will happen.

BMS systems are costly to implement and to change. Can often require large amounts of code just to change a temperature set point.

## So what can we do?

* Help facility managers identify when a building is behaving erratically (automated fault detection).
* Wealth of literature on fault detection
    + Statistical methods
    + Qualitative methods
    + Quantitative
* Buildings Alive's goal is to build an automated fault detection method to suit the data that we've collected and which can scale to multiple buildings.

# Analysing the data | Feature extraction, dimensionality reduction, clustering

## Feature extraction

* Collect data using our E2 device.
* Dealing with thousands of unevenly spaced time-series.
* We can extract features from the time-series.
* Each day of data will have

----

```{r plot-bms-raw}
data %>%
  filter(Sensor %in% sensor_sample) %>% 
  ggplot(aes(x=DT, y=Value, colour = Sensor)) +
  geom_line() + 
  facet_wrap(~Sensor, ncol = 2, scales = "free_y") +
  labs(title = "BMS data",
       x = "Date") +
  scale_color_manual(values = ba_palette) + 
  theme(legend.position = "none")
```

----

```{r plot-raw-timing}
data %>%
  filter(Sensor %in% sensor_sample,
         Time >= hms(1,1,0),
         Time < hms(1,1,3)) %>% 
  ggplot(aes(x = Time, fill = Sensor)) +
  geom_density(bw=100, alpha = 0.7, colour=NA) +
  geom_rug() + 
  facet_wrap(~Sensor, scales = "free_y", ncol = 1, strip.position = "right") +
  labs(title = "Sensor reading times",
       x = "Time") +
  scale_fill_manual(values = ba_palette) +
  theme(legend.position = "none",
        strip.text.y = element_text(angle = 0),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank())
```



## Dimension reduction and clustering

* Too many sensors to visualise easily.
* Use dimensionality reduction.

----

### Which clustering algorithm?

Method | Advantages | Disadvantages 
-------|------------|----------------
K-means | Easy to learn | Outperformed by other algorithms
K-medoids | Better performance than K-means | Can suffer from local minima
Dirichlet process | | 
Affinity propagation | Automatically determines number of clusters | 
Spectral clustering | Good performance and efficient |
Hierarchical clustering | Produces a dendrogram - no "flat" clustering | 

----

<div class="centered">
![Image: @noauthor_2017-gy](fig/cluster_comparison.png)
</div>

----

### Spectral clustering

Given $n$ points $x_i \in \mathbb{R}^p$. The graph Laplacian is defined as follows

$$
\begin{split}
\mathbf{W} &= \left(w_{ij}\right) \in \mathbb{R}^{n \times n} \\
\mathbf{D} &= \mathrm{diag} \left( d_i \right) \\
\mathbf{L} &= \mathbf{D} - \mathbf{W},
\end{split}
$$

where,

* $w_{ij}$ is the weight between nodes $i$ and $j$, and,
* $d_i = \sum_{j=1}^n w_{ij}$ is the weighted degree of node $i$.

Find the $m$ eigenvectors $\mathbf{Z}_{n \times m}$ corresponding to the $m$ smallest eigenvalues of $\mathbf{L}$. Cluster the rows of $\mathbf{Z}_{n \times m}$ using K-means.


# Building an end product | Prototyping with Dash

## Dash

<div class="columns-2">
* Recently released by Plotly.
* Easily build web applications for data analytics.
* Open sourced under the MIT license.
* Works nicely with the existing Plotly graphing libraries.
* Python equivalent of `R`'s Shiny.

![](fig/dash-logo.svg)
</div>

----

__TODO: Add screen shot of fancy Dash app.__


## Simple example {.smaller}

```{python dash-simple-app, eval=FALSE, echo=TRUE}
import dash
from dash.dependencies import Input, Output
import dash_core_components as dcc
import dash_html_components as html
import pandas as pd

app = dash.Dash()

### <b>
app.layout = html.Div([
    dcc.Dropdown(id='my-dropdown',
                 options=['A', 'B', 'C']),
    dcc.Graph(id='my-graph')
])

@app.callback(Output('my-graph', 'figure'),
              [Input('my-dropdown', 'value')])
def update_graph(dd_value):
    df_query = df.query("Variable == @dd_value")
    return {'data': [{'x': df_query.x, 'y': df_query.y}]}
### </b>
    
if __name__ == '__main__':
    app.run_server()
```

## Demonstration

# Thank-you for listening! | Any questions?

## References {-}

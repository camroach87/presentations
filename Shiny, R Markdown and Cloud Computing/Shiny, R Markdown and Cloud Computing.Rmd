---
title: "Shiny, R Markdown and Cloud Computing"
author: "Cameron Roach"
date: "4 October 2016"
output:
  ioslides_presentation:
    widescreen: true
runtime: shiny
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

# What is Shiny?

## What is Shiny?

Shiny is a wrapper for various HTML, JavaScript and CSS functions. Makes it easy to create attractive web applications.

## Can be used for

* Interactive appliations.
* Presentations (rmarkdown + ioslides + shiny).
* Dashboards (flexdashboard).
* A GUI for end-users to perform statistical analyses.

# Examples

## Interactive Plot

```{r shiny_eruptions}
inputPanel(
  selectInput("n_breaks", label = "Number of bins:",
              choices = c(10, 20, 35, 50), selected = 20),
  
  sliderInput("bw_adjust", label = "Bandwidth adjustment:",
              min = 0.2, max = 2, value = 1, step = 0.2)
)

renderPlot({
  hist(faithful$eruptions, probability = TRUE, breaks = as.numeric(input$n_breaks),
       xlab = "Duration (minutes)", main = "Geyser eruption duration")
  
  dens <- density(faithful$eruptions, adjust = input$bw_adjust)
  lines(dens, col = "blue")
})
```

## Leaflet

```{r shiny_leaflet, echo=FALSE}
library(leaflet)
library(RColorBrewer)

ui <- bootstrapPage(
  tags$style(type = "text/css",
             "html, body {width:100%;height:100%}"),
  
  leafletOutput("map", width = "100%", height = "100%"),
  
  absolutePanel(top = 10, 
                right = 10,
                draggable = TRUE,
                style = "opacity: 0.92;",
                sliderInput("range", "Magnitudes", min(quakes$mag), max(quakes$mag),
                            value = range(quakes$mag), step = 0.1
                ),
                selectInput("colors", "Color Scheme",
                            rownames(subset(brewer.pal.info, category %in% c("seq", "div")))
                ),
                checkboxInput("legend", "Show legend", TRUE)
  )
)

server <- function(input, output, session) {
  
  # Reactive expression for the data subsetted to what the user selected
  filteredData <- reactive({
    quakes[quakes$mag >= input$range[1] & quakes$mag <= input$range[2],]
  })
  
  # This reactive expression represents the palette function,
  # which changes as the user makes selections in UI.
  colorpal <- reactive({
    colorNumeric(input$colors, quakes$mag)
  })
  
  output$map <- renderLeaflet({
    # Use leaflet() here, and only include aspects of the map that
    # won't need to change dynamically (at least, not unless the
    # entire map is being torn down and recreated).
    leaflet(quakes) %>% addTiles() %>%
      fitBounds(~min(long), ~min(lat), ~max(long), ~max(lat))
  })
  
  # Incremental changes to the map (in this case, replacing the
  # circles when a new color is chosen) should be performed in
  # an observer. Each independent set of things that can change
  # should be managed in its own observer.
  observe({
    pal <- colorpal()
    
    leafletProxy("map", data = filteredData()) %>%
      clearShapes() %>%
      addCircles(radius = ~10^mag/10, weight = 1, color = "#777777",
                 fillColor = ~pal(mag), fillOpacity = 0.7, popup = ~paste(mag)
      )
  })
  
  # Use a separate observer to recreate the legend as needed.
  observe({
    proxy <- leafletProxy("map", data = quakes)
    
    # Remove any existing legend, and only if the legend is
    # enabled, create a new one.
    proxy %>% clearControls()
    if (input$legend) {
      pal <- colorpal()
      proxy %>% addLegend(position = "bottomright",
                          pal = pal, values = ~mag
      )
    }
  })
}

shinyApp(ui, server)
```


----

More examples can be found [here](http://shiny.rstudio.com/gallery/).


## Structure of a Shiny app

### User Interface
```{r shiny_structure_ui, echo=TRUE, eval=FALSE}
ui <- shinyUI(fluidPage(
  titlePanel("Plot title"),
  
  sidebarLayout(
    sidebarPanel(
      ### <b>
      sliderInput("bins", "Number of bins:", min = 1, max = 50, 
                  value = 30)
      ### </b>
    ),
    
    mainPanel(
      ### <b>
      plotOutput("distPlot")
      ###</b>
    )
  )
))
```

## Structure of a Shiny app

### Server
```{r shiny_structure_server, echo=TRUE, eval=FALSE}
server <- shinyServer(function(input, output) {
  ### <b>
  output$distPlot <- renderPlot({
    bins <- seq(min(data), max(data), length.out = input$bins + 1)
    ### </b>
    hist(data, breaks = bins)
  })
})
```

To run the application

```{r shiny_structure_run, echo=TRUE, eval=FALSE}
shinyApp(ui = ui, server = server)
```


# R Markdown

## Integrating shiny and R Markdown

RStudio makes this very easy. Simply select a new RMarkdown document and select shiny.

Works the same as a typical R Markdown document but can now add chunks that contain shiny applications.

One disadvantage is that you can no longer export static html files for distribution. Need to either publish or send raw .Rmd file.

## Example

*TODO*

# Cloud computing

## How to data science?

Dealing with large quantities of data often requires extra computational power.

High performance computing options

* Cloud services (AWS, Nectar)
* Clusters (Monarch)

## Clusters

Tried using Monarch.

Advantages

* Lots of different machines available.
* Considerable amount of computing power.

Disadvantages

* Have to schedule jobs using slurm and then wait for them to run.
* If there is an error need to debug and then reschedule the job and wait all over again.

## Cloud computing

Advantages

* Just wonderful
* It's just great
* No really, let me show you

Disadvantages

* Feel guilty about having so much power available to me and not using it all the time.

# Tying it all together

## RStudio Server

Can install with


# A snake in the grass

## For any Python users

Python can achieve similar results using Jupyter notebooks and the ipywidgets package.